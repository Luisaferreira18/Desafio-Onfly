"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActiveWorkflows = void 0;
const cron_1 = require("cron");
const n8n_workflow_1 = require("n8n-workflow");
class ActiveWorkflows {
    constructor() {
        this.activeWorkflows = {};
    }
    isActive(workflowId) {
        return this.activeWorkflows.hasOwnProperty(workflowId);
    }
    allActiveWorkflows() {
        return Object.keys(this.activeWorkflows);
    }
    get(workflowId) {
        return this.activeWorkflows[workflowId];
    }
    async add(workflowId, workflow, additionalData, mode, activation, getTriggerFunctions, getPollFunctions) {
        this.activeWorkflows[workflowId] = {};
        const triggerNodes = workflow.getTriggerNodes();
        let triggerResponse;
        this.activeWorkflows[workflowId].triggerResponses = [];
        for (const triggerNode of triggerNodes) {
            try {
                triggerResponse = await workflow.runTrigger(triggerNode, getTriggerFunctions, additionalData, mode, activation);
                if (triggerResponse !== undefined) {
                    this.activeWorkflows[workflowId].triggerResponses.push(triggerResponse);
                }
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: triggerNode });
            }
        }
        const pollingNodes = workflow.getPollNodes();
        if (pollingNodes.length === 0)
            return;
        this.activeWorkflows[workflowId].pollResponses = [];
        for (const pollNode of pollingNodes) {
            try {
                this.activeWorkflows[workflowId].pollResponses.push(await this.activatePolling(pollNode, workflow, additionalData, getPollFunctions, mode, activation));
            }
            catch (e) {
                const error = e instanceof Error ? e : new Error(`${e}`);
                throw new n8n_workflow_1.WorkflowActivationError(`There was a problem activating the workflow: "${error.message}"`, { cause: error, node: pollNode });
            }
        }
    }
    async activatePolling(node, workflow, additionalData, getPollFunctions, mode, activation) {
        const pollFunctions = getPollFunctions(workflow, node, additionalData, mode, activation);
        const pollTimes = pollFunctions.getNodeParameter('pollTimes');
        const cronTimes = (pollTimes.item || []).map(n8n_workflow_1.toCronExpression);
        const executeTrigger = async (testingTrigger = false) => {
            n8n_workflow_1.LoggerProxy.debug(`Polling trigger initiated for workflow "${workflow.name}"`, {
                workflowName: workflow.name,
                workflowId: workflow.id,
            });
            try {
                const pollResponse = await workflow.runPoll(node, pollFunctions);
                if (pollResponse !== null) {
                    pollFunctions.__emit(pollResponse);
                }
            }
            catch (error) {
                if (testingTrigger) {
                    throw error;
                }
                pollFunctions.__emitError(error);
            }
        };
        await executeTrigger(true);
        const timezone = pollFunctions.getTimezone();
        const cronJobs = [];
        for (const cronTime of cronTimes) {
            const cronTimeParts = cronTime.split(' ');
            if (cronTimeParts.length > 0 && cronTimeParts[0].includes('*')) {
                throw new Error('The polling interval is too short. It has to be at least a minute!');
            }
            cronJobs.push(new cron_1.CronJob(cronTime, executeTrigger, undefined, true, timezone));
        }
        async function closeFunction() {
            for (const cronJob of cronJobs) {
                cronJob.stop();
            }
        }
        return {
            closeFunction,
        };
    }
    async remove(workflowId) {
        var _a, _b;
        if (!this.isActive(workflowId)) {
            n8n_workflow_1.LoggerProxy.warn(`Cannot deactivate already inactive workflow ID "${workflowId}"`);
            return false;
        }
        const w = this.activeWorkflows[workflowId];
        (_a = w.triggerResponses) === null || _a === void 0 ? void 0 : _a.forEach(async (r) => this.close(r, workflowId, 'trigger'));
        (_b = w.pollResponses) === null || _b === void 0 ? void 0 : _b.forEach(async (r) => this.close(r, workflowId, 'poller'));
        delete this.activeWorkflows[workflowId];
        return true;
    }
    async removeAllTriggerAndPollerBasedWorkflows() {
        var _a, _b;
        for (const workflowId of Object.keys(this.activeWorkflows)) {
            const w = this.activeWorkflows[workflowId];
            (_a = w.triggerResponses) === null || _a === void 0 ? void 0 : _a.forEach(async (r) => this.close(r, workflowId, 'trigger'));
            (_b = w.pollResponses) === null || _b === void 0 ? void 0 : _b.forEach(async (r) => this.close(r, workflowId, 'poller'));
        }
    }
    async close(response, workflowId, target) {
        if (!response.closeFunction)
            return;
        try {
            await response.closeFunction();
        }
        catch (e) {
            const error = e instanceof Error ? e : new Error(`${e}`);
            throw new n8n_workflow_1.WorkflowDeactivationError(`Failed to deactivate ${target} of workflow ID "${workflowId}": "${error.message}"`, { cause: error, workflowId });
        }
    }
}
exports.ActiveWorkflows = ActiveWorkflows;
//# sourceMappingURL=ActiveWorkflows.js.map